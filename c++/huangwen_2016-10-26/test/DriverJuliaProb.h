/*
This file is the driver for problem defined by Julia functions.
The Julia driver "DriverOPT.m" creates function handles of a cost function and
parameters for both solvers and manifolds, which are passing to the
binary file generated by this C++ driver.

---- WH
*/

#ifndef DRIVERJULIAPROB_H
#define DRIVERJULIAPROB_H

#include "ForDebug.h"
#include <iostream>
#include <cstring>
#include "randgen.h"
#include "Manifold.h"
#include "Problem.h"
#include "SolversLS.h"
#include <ctime>

#include "Euclidean.h"
#include "EucVariable.h"
#include "EucVector.h"

#include "StieVector.h"
#include "StieVariable.h"
#include "Stiefel.h"

#include "RSD.h"
#include "RNewton.h"
#include "RCG.h"
#include "RBroydenFamily.h"
#include "RWRBFGS.h"
#include "RBFGS.h"
#include "LRBFGS.h"
#include "RBFGSLPSub.h"
#include "LRBFGSLPSub.h"
#include "RGS.h"

#include "SolversTR.h"
#include "RTRSD.h"
#include "RTRNewton.h"
#include "RTRSR1.h"
#include "LRTRSR1.h"

#include "def.h"

#include "Sphere.h"
#include "SphereVariable.h"
#include "SphereVector.h"

#include "Oblique.h"
#include "ObliqueVariable.h"
#include "ObliqueVector.h"

#include "LowRank.h"
#include "LowRankVariable.h"
#include "LowRankVector.h"

#include "OrthGroup.h"
#include "OrthGroupVariable.h"
#include "OrthGroupVector.h"

#include "SPDManifold.h"
#include "SPDVariable.h"
#include "SPDVector.h"

#include "L2Sphere.h"
#include "L2SphereVariable.h"
#include "L2SphereVector.h"

#include "CpxNStQOrth.h"
#include "CSOVariable.h"
#include "CSOVector.h"

#include "CpxNStQOrth.h"
#include "CSOVariable.h"
#include "CSOVector.h"

#include "Grassmann.h"
#include "GrassVariable.h"
#include "GrassVector.h"

#include "EucPositive.h"
#include "EucPosVariable.h"
#include "EucPosVector.h"

#include "PreShapeCurves.h"
#include "PSCVariable.h"
#include "PSCVector.h"

#include "SPDTensor.h"
#include "SPDTVariable.h"
#include "SPDTVector.h"

#include "ProductElement.h"
#include "ProductManifold.h"

#include <juliaProblem.h>
#include "julia.h"

using namespace ROPTLIB;

struct FunHandles {
    const char *fname;
    const char *gfname;
    const char *hfname;
    const char *isstopped;
    const char *LinesearchInput;
};

struct SolverParams {
    long int IsCheckParams;
    long int IsCheckGradHess;
    const char *name;
    //Solvers
    long int Stop_Criterion;
    double Tolerance;
    double Diffx;
    long int NumExtraGF;
    long int TimeBound;
    long int Min_Iteration;
    long int Max_Iteration;
    long int OutputGap;
    long int DEBUG;
    //QuasiNewton
    long int isconvex;
    double nu;
    double mu;
    long int LengthSY;
    double lambdaLower;
    double lambdaUpper;
    //SolversLS
    long int LineSearch_LS;
    long int IsPureLSInput;
    double LS_alpha;
    double LS_beta;
    double Minstepsize;
    double Maxstepsize;
    double LS_ratio1;
    double LS_ratio2;
    double Initstepsize;
    double Accuracy;
    double Finalstepsize;
    long int Num_pre_funs;
    long int InitSteptype;
    //SolversTR
    double Acceptence_Rho;
    double Shrinked_tau;
    double Magnified_tau;
    double minimum_Delta;
    double maximum_Delta;
    long int useRand;
    long int Max_Inner_Iter;
    long int Min_Inner_Iter;
    double theta;
    double kappa;
    double initial_Delta;
    //SolversLSLPSub
    double Eps;
    double Theta_eps;
    double Min_Eps;
    double Del;
    double Theta_del;
};

struct ManiParams {
    long int IsCheckParams;
    long int numoftypes;
    const char **name;
    long int *numofmani;
    long int *paramset;
    long int *m;
    long int *n;
    long int *p;
};

/*This function checks the number and formats of input parameters.
nlhs: the number of output in mxArray format
plhs: the output objects in mxArray format
nrhs: the number of input in mxArray format
prhs: the input objects in mxArray format */
double *DriverJuliaProb(struct FunHandles *Handles, struct SolverParams *Sparams,
                     struct ManiParams *Mparams, integer inHasHHR, double *X0, integer length_X0);

/*This file creates a C++ solver based on the input parameters and run the solver to obtain a solution.*/
double *ParseSolverParamsAndOptimizing(struct SolverParams *Sparams, struct FunHandles *Handles, Problem *Prob, Variable *initialX);

/*This file creates all components of the product manifolds. Note that the cost function is always
defined on a product manifolds.*/
bool ParseManiParams(struct ManiParams *Mparams, Manifold **&manifolds, Element **&elements,
    integer *&powsinterval, integer &numoftype, integer &numoftotal);

/*Create a manifold based on the parameters.*/
Manifold *GetAManifold(const char *name, integer n, integer m, integer p = 1);

/*Create an element based on the parameters. Note that the element is a component of the initial iterate.*/
Element *GetAnElement(const char *name, integer n, integer m, integer p = 1);


namespace RJULIA{
    extern jl_function_t *isstopped;
    /*This function defines the stopping criterion that may be used in the C++ solver*/
    bool juliaInnerStop(Variable *x, Vector *gf, double f, double ngf, double ngf0);
    extern jl_function_t *LinesearchInput;
    /*This function defines the line search algorithm that may be used in the C++ solver*/
    double juliaLinesearchInput(Variable *x1, Vector *eta1, double initialstepsize, double initialslope, const Problem *prob);
};

#endif // end of DRIVERMEXPROB_H
